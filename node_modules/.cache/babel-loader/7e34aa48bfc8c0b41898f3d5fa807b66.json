{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar _a;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar invariant_1 = __importDefault(require(\"invariant\"));\n\nvar interfaces_1 = require(\"./interfaces\");\n\nvar predicates_1 = require(\"./utils/predicates\");\n\nvar offsets_1 = require(\"./utils/offsets\");\n\nvar math_1 = require(\"./utils/math\");\n\nvar supportsPassive_1 = __importDefault(require(\"./utils/supportsPassive\"));\n\nvar OptionsReader_1 = require(\"./OptionsReader\");\n\nvar eventNames = (_a = {}, _a[interfaces_1.ListenerType.mouse] = {\n  start: 'mousedown',\n  move: 'mousemove',\n  end: 'mouseup',\n  contextmenu: 'contextmenu'\n}, _a[interfaces_1.ListenerType.touch] = {\n  start: 'touchstart',\n  move: 'touchmove',\n  end: 'touchend'\n}, _a[interfaces_1.ListenerType.keyboard] = {\n  keydown: 'keydown'\n}, _a);\n\nvar TouchBackend =\n/** @class */\nfunction () {\n  function TouchBackend(manager, context, options) {\n    var _this = this;\n\n    this.getSourceClientOffset = function (sourceId) {\n      return offsets_1.getNodeClientOffset(_this.sourceNodes[sourceId]);\n    };\n\n    this.handleTopMoveStartCapture = function (e) {\n      if (!predicates_1.eventShouldStartDrag(e)) {\n        return;\n      }\n\n      _this.moveStartSourceIds = [];\n    };\n\n    this.handleMoveStart = function (sourceId) {\n      // Just because we received an event doesn't necessarily mean we need to collect drag sources.\n      // We only collect start collecting drag sources on touch and left mouse events.\n      if (Array.isArray(_this.moveStartSourceIds)) {\n        _this.moveStartSourceIds.unshift(sourceId);\n      }\n    };\n\n    this.handleTopMoveStart = function (e) {\n      if (!predicates_1.eventShouldStartDrag(e)) {\n        return;\n      } // Don't prematurely preventDefault() here since it might:\n      // 1. Mess up scrolling\n      // 2. Mess up long tap (which brings up context menu)\n      // 3. If there's an anchor link as a child, tap won't be triggered on link\n\n\n      var clientOffset = offsets_1.getEventClientOffset(e);\n\n      if (clientOffset) {\n        _this._mouseClientOffset = clientOffset;\n      }\n\n      _this.waitingForDelay = false;\n    };\n\n    this.handleTopMoveStartDelay = function (e) {\n      if (!predicates_1.eventShouldStartDrag(e)) {\n        return;\n      }\n\n      var delay = e.type === eventNames.touch.start ? _this.options.delayTouchStart : _this.options.delayMouseStart;\n      _this.timeout = setTimeout(_this.handleTopMoveStart.bind(_this, e), delay);\n      _this.waitingForDelay = true;\n    };\n\n    this.handleTopMoveCapture = function () {\n      _this.dragOverTargetIds = [];\n    };\n\n    this.handleMove = function (_, targetId) {\n      if (_this.dragOverTargetIds) {\n        _this.dragOverTargetIds.unshift(targetId);\n      }\n    };\n\n    this.handleTopMove = function (e) {\n      if (_this.timeout) {\n        clearTimeout(_this.timeout);\n      }\n\n      if (!_this.document || _this.waitingForDelay) {\n        return;\n      }\n\n      var _a = _this,\n          moveStartSourceIds = _a.moveStartSourceIds,\n          dragOverTargetIds = _a.dragOverTargetIds;\n      var enableHoverOutsideTarget = _this.options.enableHoverOutsideTarget;\n      var clientOffset = offsets_1.getEventClientOffset(e);\n\n      if (!clientOffset) {\n        return;\n      } // If the touch move started as a scroll, or is is between the scroll angles\n\n\n      if (_this._isScrolling || !_this.monitor.isDragging() && math_1.inAngleRanges(_this._mouseClientOffset.x || 0, _this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y, _this.options.scrollAngleRanges)) {\n        _this._isScrolling = true;\n        return;\n      } // If we're not dragging and we've moved a little, that counts as a drag start\n\n\n      if (!_this.monitor.isDragging() && // eslint-disable-next-line no-prototype-builtins\n      _this._mouseClientOffset.hasOwnProperty('x') && moveStartSourceIds && math_1.distance(_this._mouseClientOffset.x || 0, _this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y) > (_this.options.touchSlop ? _this.options.touchSlop : 0)) {\n        _this.moveStartSourceIds = undefined;\n\n        _this.actions.beginDrag(moveStartSourceIds, {\n          clientOffset: _this._mouseClientOffset,\n          getSourceClientOffset: _this.getSourceClientOffset,\n          publishSource: false\n        });\n      }\n\n      if (!_this.monitor.isDragging()) {\n        return;\n      }\n\n      var sourceNode = _this.sourceNodes[_this.monitor.getSourceId()];\n\n      _this.installSourceNodeRemovalObserver(sourceNode);\n\n      _this.actions.publishDragSource();\n\n      e.preventDefault(); // Get the node elements of the hovered DropTargets\n\n      var dragOverTargetNodes = (dragOverTargetIds || []).map(function (key) {\n        return _this.targetNodes[key];\n      }); // Get the a ordered list of nodes that are touched by\n\n      var elementsAtPoint = _this.options.getDropTargetElementsAtPoint ? _this.options.getDropTargetElementsAtPoint(clientOffset.x, clientOffset.y, dragOverTargetNodes) : _this.document.elementsFromPoint(clientOffset.x, clientOffset.y); // Extend list with parents that are not receiving elementsFromPoint events (size 0 elements and svg groups)\n\n      var elementsAtPointExtended = [];\n\n      for (var nodeId in elementsAtPoint) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (!elementsAtPoint.hasOwnProperty(nodeId)) {\n          continue;\n        }\n\n        var currentNode = elementsAtPoint[nodeId];\n        elementsAtPointExtended.push(currentNode);\n\n        while (currentNode) {\n          currentNode = currentNode.parentElement;\n\n          if (elementsAtPointExtended.indexOf(currentNode) === -1) {\n            elementsAtPointExtended.push(currentNode);\n          }\n        }\n      }\n\n      var orderedDragOverTargetIds = elementsAtPointExtended // Filter off nodes that arent a hovered DropTargets nodes\n      .filter(function (node) {\n        return dragOverTargetNodes.indexOf(node) > -1;\n      }) // Map back the nodes elements to targetIds\n      .map(function (node) {\n        for (var targetId in _this.targetNodes) {\n          if (node === _this.targetNodes[targetId]) {\n            return targetId;\n          }\n        }\n\n        return undefined;\n      }) // Filter off possible null rows\n      .filter(function (node) {\n        return !!node;\n      }).filter(function (id, index, ids) {\n        return ids.indexOf(id) === index;\n      }); // Invoke hover for drop targets when source node is still over and pointer is outside\n\n      if (enableHoverOutsideTarget) {\n        for (var targetId in _this.targetNodes) {\n          if (_this.targetNodes[targetId] && _this.targetNodes[targetId].contains(sourceNode) && orderedDragOverTargetIds.indexOf(targetId) === -1) {\n            orderedDragOverTargetIds.unshift(targetId);\n            break;\n          }\n        }\n      } // Reverse order because dnd-core reverse it before calling the DropTarget drop methods\n\n\n      orderedDragOverTargetIds.reverse();\n\n      _this.actions.hover(orderedDragOverTargetIds, {\n        clientOffset: clientOffset\n      });\n    };\n\n    this.handleTopMoveEndCapture = function (e) {\n      _this._isScrolling = false;\n\n      if (!predicates_1.eventShouldEndDrag(e)) {\n        return;\n      }\n\n      if (!_this.monitor.isDragging() || _this.monitor.didDrop()) {\n        _this.moveStartSourceIds = undefined;\n        return;\n      }\n\n      e.preventDefault();\n      _this._mouseClientOffset = {};\n\n      _this.uninstallSourceNodeRemovalObserver();\n\n      _this.actions.drop();\n\n      _this.actions.endDrag();\n    };\n\n    this.handleCancelOnEscape = function (e) {\n      if (e.key === 'Escape' && _this.monitor.isDragging()) {\n        _this._mouseClientOffset = {};\n\n        _this.uninstallSourceNodeRemovalObserver();\n\n        _this.actions.endDrag();\n      }\n    };\n\n    this.options = new OptionsReader_1.OptionsReader(options, context);\n    this.actions = manager.getActions();\n    this.monitor = manager.getMonitor();\n    this.sourceNodes = {};\n    this.sourcePreviewNodes = {};\n    this.sourcePreviewNodeOptions = {};\n    this.targetNodes = {};\n    this.listenerTypes = [];\n    this._mouseClientOffset = {};\n    this._isScrolling = false;\n\n    if (this.options.enableMouseEvents) {\n      this.listenerTypes.push(interfaces_1.ListenerType.mouse);\n    }\n\n    if (this.options.enableTouchEvents) {\n      this.listenerTypes.push(interfaces_1.ListenerType.touch);\n    }\n\n    if (this.options.enableKeyboardEvents) {\n      this.listenerTypes.push(interfaces_1.ListenerType.keyboard);\n    }\n  }\n\n  Object.defineProperty(TouchBackend.prototype, \"window\", {\n    // public for test\n    get: function () {\n      return this.options.window;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TouchBackend.prototype, \"document\", {\n    // public for test\n    get: function () {\n      if (this.window) {\n        return this.window.document;\n      }\n\n      return undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  TouchBackend.prototype.setup = function () {\n    if (!this.window) {\n      return;\n    }\n\n    invariant_1.default(!TouchBackend.isSetUp, 'Cannot have two Touch backends at the same time.');\n    TouchBackend.isSetUp = true;\n    this.addEventListener(this.window, 'start', this.getTopMoveStartHandler());\n    this.addEventListener(this.window, 'start', this.handleTopMoveStartCapture, true);\n    this.addEventListener(this.window, 'move', this.handleTopMove);\n    this.addEventListener(this.window, 'move', this.handleTopMoveCapture, true);\n    this.addEventListener(this.window, 'end', this.handleTopMoveEndCapture, true);\n\n    if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n      this.addEventListener(this.window, 'contextmenu', this.handleTopMoveEndCapture);\n    }\n\n    if (this.options.enableKeyboardEvents) {\n      this.addEventListener(this.window, 'keydown', this.handleCancelOnEscape, true);\n    }\n  };\n\n  TouchBackend.prototype.teardown = function () {\n    if (!this.window) {\n      return;\n    }\n\n    TouchBackend.isSetUp = false;\n    this._mouseClientOffset = {};\n    this.removeEventListener(this.window, 'start', this.handleTopMoveStartCapture, true);\n    this.removeEventListener(this.window, 'start', this.handleTopMoveStart);\n    this.removeEventListener(this.window, 'move', this.handleTopMoveCapture, true);\n    this.removeEventListener(this.window, 'move', this.handleTopMove);\n    this.removeEventListener(this.window, 'end', this.handleTopMoveEndCapture, true);\n\n    if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n      this.removeEventListener(this.window, 'contextmenu', this.handleTopMoveEndCapture);\n    }\n\n    if (this.options.enableKeyboardEvents) {\n      this.removeEventListener(this.window, 'keydown', this.handleCancelOnEscape, true);\n    }\n\n    this.uninstallSourceNodeRemovalObserver();\n  };\n\n  TouchBackend.prototype.addEventListener = function (subject, event, handler, capture) {\n    var options = supportsPassive_1.default ? {\n      capture: capture,\n      passive: false\n    } : capture;\n    this.listenerTypes.forEach(function (listenerType) {\n      var evt = eventNames[listenerType][event];\n\n      if (evt) {\n        subject.addEventListener(evt, handler, options);\n      }\n    });\n  };\n\n  TouchBackend.prototype.removeEventListener = function (subject, event, handler, capture) {\n    var options = supportsPassive_1.default ? {\n      capture: capture,\n      passive: false\n    } : capture;\n    this.listenerTypes.forEach(function (listenerType) {\n      var evt = eventNames[listenerType][event];\n\n      if (evt) {\n        subject.removeEventListener(evt, handler, options);\n      }\n    });\n  };\n\n  TouchBackend.prototype.connectDragSource = function (sourceId, node) {\n    var _this = this;\n\n    var handleMoveStart = this.handleMoveStart.bind(this, sourceId);\n    this.sourceNodes[sourceId] = node;\n    this.addEventListener(node, 'start', handleMoveStart);\n    return function () {\n      delete _this.sourceNodes[sourceId];\n\n      _this.removeEventListener(node, 'start', handleMoveStart);\n    };\n  };\n\n  TouchBackend.prototype.connectDragPreview = function (sourceId, node, options) {\n    var _this = this;\n\n    this.sourcePreviewNodeOptions[sourceId] = options;\n    this.sourcePreviewNodes[sourceId] = node;\n    return function () {\n      delete _this.sourcePreviewNodes[sourceId];\n      delete _this.sourcePreviewNodeOptions[sourceId];\n    };\n  };\n\n  TouchBackend.prototype.connectDropTarget = function (targetId, node) {\n    var _this = this;\n\n    if (!this.document) {\n      return function () {\n        return null;\n      };\n    }\n\n    var handleMove = function (e) {\n      if (!_this.document || !_this.monitor.isDragging()) {\n        return;\n      }\n\n      var coords;\n      /**\n       * Grab the coordinates for the current mouse/touch position\n       */\n\n      switch (e.type) {\n        case eventNames.mouse.move:\n          coords = {\n            x: e.clientX,\n            y: e.clientY\n          };\n          break;\n\n        case eventNames.touch.move:\n          coords = {\n            x: e.touches[0].clientX,\n            y: e.touches[0].clientY\n          };\n          break;\n      }\n      /**\n       * Use the coordinates to grab the element the drag ended on.\n       * If the element is the same as the target node (or any of it's children) then we have hit a drop target and can handle the move.\n       */\n\n\n      var droppedOn = coords != null ? _this.document.elementFromPoint(coords.x, coords.y) : undefined;\n      var childMatch = droppedOn && node.contains(droppedOn);\n\n      if (droppedOn === node || childMatch) {\n        return _this.handleMove(e, targetId);\n      }\n    };\n    /**\n     * Attaching the event listener to the body so that touchmove will work while dragging over multiple target elements.\n     */\n\n\n    this.addEventListener(this.document.body, 'move', handleMove);\n    this.targetNodes[targetId] = node;\n    return function () {\n      if (_this.document) {\n        delete _this.targetNodes[targetId];\n\n        _this.removeEventListener(_this.document.body, 'move', handleMove);\n      }\n    };\n  };\n\n  TouchBackend.prototype.getTopMoveStartHandler = function () {\n    if (!this.options.delayTouchStart && !this.options.delayMouseStart) {\n      return this.handleTopMoveStart;\n    }\n\n    return this.handleTopMoveStartDelay;\n  };\n\n  TouchBackend.prototype.installSourceNodeRemovalObserver = function (node) {\n    var _this = this;\n\n    this.uninstallSourceNodeRemovalObserver();\n    this.draggedSourceNode = node;\n    this.draggedSourceNodeRemovalObserver = new MutationObserver(function () {\n      if (node && !node.parentElement) {\n        _this.resurrectSourceNode();\n\n        _this.uninstallSourceNodeRemovalObserver();\n      }\n    });\n\n    if (!node || !node.parentElement) {\n      return;\n    }\n\n    this.draggedSourceNodeRemovalObserver.observe(node.parentElement, {\n      childList: true\n    });\n  };\n\n  TouchBackend.prototype.resurrectSourceNode = function () {\n    if (this.document && this.draggedSourceNode) {\n      this.draggedSourceNode.style.display = 'none';\n      this.draggedSourceNode.removeAttribute('data-reactid');\n      this.document.body.appendChild(this.draggedSourceNode);\n    }\n  };\n\n  TouchBackend.prototype.uninstallSourceNodeRemovalObserver = function () {\n    if (this.draggedSourceNodeRemovalObserver) {\n      this.draggedSourceNodeRemovalObserver.disconnect();\n    }\n\n    this.draggedSourceNodeRemovalObserver = undefined;\n    this.draggedSourceNode = undefined;\n  };\n\n  return TouchBackend;\n}();\n\nexports.default = TouchBackend;","map":{"version":3,"sources":["/home/janne/repot/OperaatioJyrki/node_modules/react-dnd-touch-backend-cjs/lib/TouchBackend.js"],"names":["__importDefault","mod","__esModule","_a","Object","defineProperty","exports","value","invariant_1","require","interfaces_1","predicates_1","offsets_1","math_1","supportsPassive_1","OptionsReader_1","eventNames","ListenerType","mouse","start","move","end","contextmenu","touch","keyboard","keydown","TouchBackend","manager","context","options","_this","getSourceClientOffset","sourceId","getNodeClientOffset","sourceNodes","handleTopMoveStartCapture","e","eventShouldStartDrag","moveStartSourceIds","handleMoveStart","Array","isArray","unshift","handleTopMoveStart","clientOffset","getEventClientOffset","_mouseClientOffset","waitingForDelay","handleTopMoveStartDelay","delay","type","delayTouchStart","delayMouseStart","timeout","setTimeout","bind","handleTopMoveCapture","dragOverTargetIds","handleMove","_","targetId","handleTopMove","clearTimeout","document","enableHoverOutsideTarget","_isScrolling","monitor","isDragging","inAngleRanges","x","y","scrollAngleRanges","hasOwnProperty","distance","touchSlop","undefined","actions","beginDrag","publishSource","sourceNode","getSourceId","installSourceNodeRemovalObserver","publishDragSource","preventDefault","dragOverTargetNodes","map","key","targetNodes","elementsAtPoint","getDropTargetElementsAtPoint","elementsFromPoint","elementsAtPointExtended","nodeId","currentNode","push","parentElement","indexOf","orderedDragOverTargetIds","filter","node","id","index","ids","contains","reverse","hover","handleTopMoveEndCapture","eventShouldEndDrag","didDrop","uninstallSourceNodeRemovalObserver","drop","endDrag","handleCancelOnEscape","OptionsReader","getActions","getMonitor","sourcePreviewNodes","sourcePreviewNodeOptions","listenerTypes","enableMouseEvents","enableTouchEvents","enableKeyboardEvents","prototype","get","window","enumerable","configurable","setup","default","isSetUp","addEventListener","getTopMoveStartHandler","ignoreContextMenu","teardown","removeEventListener","subject","event","handler","capture","passive","forEach","listenerType","evt","connectDragSource","connectDragPreview","connectDropTarget","coords","clientX","clientY","touches","droppedOn","elementFromPoint","childMatch","body","draggedSourceNode","draggedSourceNodeRemovalObserver","MutationObserver","resurrectSourceNode","observe","childList","style","display","removeAttribute","appendChild","disconnect"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = __importDefault(require(\"invariant\"));\nvar interfaces_1 = require(\"./interfaces\");\nvar predicates_1 = require(\"./utils/predicates\");\nvar offsets_1 = require(\"./utils/offsets\");\nvar math_1 = require(\"./utils/math\");\nvar supportsPassive_1 = __importDefault(require(\"./utils/supportsPassive\"));\nvar OptionsReader_1 = require(\"./OptionsReader\");\nvar eventNames = (_a = {},\n    _a[interfaces_1.ListenerType.mouse] = {\n        start: 'mousedown',\n        move: 'mousemove',\n        end: 'mouseup',\n        contextmenu: 'contextmenu',\n    },\n    _a[interfaces_1.ListenerType.touch] = {\n        start: 'touchstart',\n        move: 'touchmove',\n        end: 'touchend',\n    },\n    _a[interfaces_1.ListenerType.keyboard] = {\n        keydown: 'keydown',\n    },\n    _a);\nvar TouchBackend = /** @class */ (function () {\n    function TouchBackend(manager, context, options) {\n        var _this = this;\n        this.getSourceClientOffset = function (sourceId) {\n            return offsets_1.getNodeClientOffset(_this.sourceNodes[sourceId]);\n        };\n        this.handleTopMoveStartCapture = function (e) {\n            if (!predicates_1.eventShouldStartDrag(e)) {\n                return;\n            }\n            _this.moveStartSourceIds = [];\n        };\n        this.handleMoveStart = function (sourceId) {\n            // Just because we received an event doesn't necessarily mean we need to collect drag sources.\n            // We only collect start collecting drag sources on touch and left mouse events.\n            if (Array.isArray(_this.moveStartSourceIds)) {\n                _this.moveStartSourceIds.unshift(sourceId);\n            }\n        };\n        this.handleTopMoveStart = function (e) {\n            if (!predicates_1.eventShouldStartDrag(e)) {\n                return;\n            }\n            // Don't prematurely preventDefault() here since it might:\n            // 1. Mess up scrolling\n            // 2. Mess up long tap (which brings up context menu)\n            // 3. If there's an anchor link as a child, tap won't be triggered on link\n            var clientOffset = offsets_1.getEventClientOffset(e);\n            if (clientOffset) {\n                _this._mouseClientOffset = clientOffset;\n            }\n            _this.waitingForDelay = false;\n        };\n        this.handleTopMoveStartDelay = function (e) {\n            if (!predicates_1.eventShouldStartDrag(e)) {\n                return;\n            }\n            var delay = e.type === eventNames.touch.start\n                ? _this.options.delayTouchStart\n                : _this.options.delayMouseStart;\n            _this.timeout = setTimeout(_this.handleTopMoveStart.bind(_this, e), delay);\n            _this.waitingForDelay = true;\n        };\n        this.handleTopMoveCapture = function () {\n            _this.dragOverTargetIds = [];\n        };\n        this.handleMove = function (_, targetId) {\n            if (_this.dragOverTargetIds) {\n                _this.dragOverTargetIds.unshift(targetId);\n            }\n        };\n        this.handleTopMove = function (e) {\n            if (_this.timeout) {\n                clearTimeout(_this.timeout);\n            }\n            if (!_this.document || _this.waitingForDelay) {\n                return;\n            }\n            var _a = _this, moveStartSourceIds = _a.moveStartSourceIds, dragOverTargetIds = _a.dragOverTargetIds;\n            var enableHoverOutsideTarget = _this.options.enableHoverOutsideTarget;\n            var clientOffset = offsets_1.getEventClientOffset(e);\n            if (!clientOffset) {\n                return;\n            }\n            // If the touch move started as a scroll, or is is between the scroll angles\n            if (_this._isScrolling ||\n                (!_this.monitor.isDragging() &&\n                    math_1.inAngleRanges(_this._mouseClientOffset.x || 0, _this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y, _this.options.scrollAngleRanges))) {\n                _this._isScrolling = true;\n                return;\n            }\n            // If we're not dragging and we've moved a little, that counts as a drag start\n            if (!_this.monitor.isDragging() &&\n                // eslint-disable-next-line no-prototype-builtins\n                _this._mouseClientOffset.hasOwnProperty('x') &&\n                moveStartSourceIds &&\n                math_1.distance(_this._mouseClientOffset.x || 0, _this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y) > (_this.options.touchSlop ? _this.options.touchSlop : 0)) {\n                _this.moveStartSourceIds = undefined;\n                _this.actions.beginDrag(moveStartSourceIds, {\n                    clientOffset: _this._mouseClientOffset,\n                    getSourceClientOffset: _this.getSourceClientOffset,\n                    publishSource: false,\n                });\n            }\n            if (!_this.monitor.isDragging()) {\n                return;\n            }\n            var sourceNode = _this.sourceNodes[_this.monitor.getSourceId()];\n            _this.installSourceNodeRemovalObserver(sourceNode);\n            _this.actions.publishDragSource();\n            e.preventDefault();\n            // Get the node elements of the hovered DropTargets\n            var dragOverTargetNodes = (dragOverTargetIds || []).map(function (key) { return _this.targetNodes[key]; });\n            // Get the a ordered list of nodes that are touched by\n            var elementsAtPoint = _this.options.getDropTargetElementsAtPoint\n                ? _this.options.getDropTargetElementsAtPoint(clientOffset.x, clientOffset.y, dragOverTargetNodes)\n                : _this.document.elementsFromPoint(clientOffset.x, clientOffset.y);\n            // Extend list with parents that are not receiving elementsFromPoint events (size 0 elements and svg groups)\n            var elementsAtPointExtended = [];\n            for (var nodeId in elementsAtPoint) {\n                // eslint-disable-next-line no-prototype-builtins\n                if (!elementsAtPoint.hasOwnProperty(nodeId)) {\n                    continue;\n                }\n                var currentNode = elementsAtPoint[nodeId];\n                elementsAtPointExtended.push(currentNode);\n                while (currentNode) {\n                    currentNode = currentNode.parentElement;\n                    if (elementsAtPointExtended.indexOf(currentNode) === -1) {\n                        elementsAtPointExtended.push(currentNode);\n                    }\n                }\n            }\n            var orderedDragOverTargetIds = elementsAtPointExtended\n                // Filter off nodes that arent a hovered DropTargets nodes\n                .filter(function (node) { return dragOverTargetNodes.indexOf(node) > -1; })\n                // Map back the nodes elements to targetIds\n                .map(function (node) {\n                for (var targetId in _this.targetNodes) {\n                    if (node === _this.targetNodes[targetId]) {\n                        return targetId;\n                    }\n                }\n                return undefined;\n            })\n                // Filter off possible null rows\n                .filter(function (node) { return !!node; })\n                .filter(function (id, index, ids) { return ids.indexOf(id) === index; });\n            // Invoke hover for drop targets when source node is still over and pointer is outside\n            if (enableHoverOutsideTarget) {\n                for (var targetId in _this.targetNodes) {\n                    if (_this.targetNodes[targetId] &&\n                        _this.targetNodes[targetId].contains(sourceNode) &&\n                        orderedDragOverTargetIds.indexOf(targetId) === -1) {\n                        orderedDragOverTargetIds.unshift(targetId);\n                        break;\n                    }\n                }\n            }\n            // Reverse order because dnd-core reverse it before calling the DropTarget drop methods\n            orderedDragOverTargetIds.reverse();\n            _this.actions.hover(orderedDragOverTargetIds, {\n                clientOffset: clientOffset,\n            });\n        };\n        this.handleTopMoveEndCapture = function (e) {\n            _this._isScrolling = false;\n            if (!predicates_1.eventShouldEndDrag(e)) {\n                return;\n            }\n            if (!_this.monitor.isDragging() || _this.monitor.didDrop()) {\n                _this.moveStartSourceIds = undefined;\n                return;\n            }\n            e.preventDefault();\n            _this._mouseClientOffset = {};\n            _this.uninstallSourceNodeRemovalObserver();\n            _this.actions.drop();\n            _this.actions.endDrag();\n        };\n        this.handleCancelOnEscape = function (e) {\n            if (e.key === 'Escape' && _this.monitor.isDragging()) {\n                _this._mouseClientOffset = {};\n                _this.uninstallSourceNodeRemovalObserver();\n                _this.actions.endDrag();\n            }\n        };\n        this.options = new OptionsReader_1.OptionsReader(options, context);\n        this.actions = manager.getActions();\n        this.monitor = manager.getMonitor();\n        this.sourceNodes = {};\n        this.sourcePreviewNodes = {};\n        this.sourcePreviewNodeOptions = {};\n        this.targetNodes = {};\n        this.listenerTypes = [];\n        this._mouseClientOffset = {};\n        this._isScrolling = false;\n        if (this.options.enableMouseEvents) {\n            this.listenerTypes.push(interfaces_1.ListenerType.mouse);\n        }\n        if (this.options.enableTouchEvents) {\n            this.listenerTypes.push(interfaces_1.ListenerType.touch);\n        }\n        if (this.options.enableKeyboardEvents) {\n            this.listenerTypes.push(interfaces_1.ListenerType.keyboard);\n        }\n    }\n    Object.defineProperty(TouchBackend.prototype, \"window\", {\n        // public for test\n        get: function () {\n            return this.options.window;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TouchBackend.prototype, \"document\", {\n        // public for test\n        get: function () {\n            if (this.window) {\n                return this.window.document;\n            }\n            return undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TouchBackend.prototype.setup = function () {\n        if (!this.window) {\n            return;\n        }\n        invariant_1.default(!TouchBackend.isSetUp, 'Cannot have two Touch backends at the same time.');\n        TouchBackend.isSetUp = true;\n        this.addEventListener(this.window, 'start', this.getTopMoveStartHandler());\n        this.addEventListener(this.window, 'start', this.handleTopMoveStartCapture, true);\n        this.addEventListener(this.window, 'move', this.handleTopMove);\n        this.addEventListener(this.window, 'move', this.handleTopMoveCapture, true);\n        this.addEventListener(this.window, 'end', this.handleTopMoveEndCapture, true);\n        if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n            this.addEventListener(this.window, 'contextmenu', this.handleTopMoveEndCapture);\n        }\n        if (this.options.enableKeyboardEvents) {\n            this.addEventListener(this.window, 'keydown', this.handleCancelOnEscape, true);\n        }\n    };\n    TouchBackend.prototype.teardown = function () {\n        if (!this.window) {\n            return;\n        }\n        TouchBackend.isSetUp = false;\n        this._mouseClientOffset = {};\n        this.removeEventListener(this.window, 'start', this.handleTopMoveStartCapture, true);\n        this.removeEventListener(this.window, 'start', this.handleTopMoveStart);\n        this.removeEventListener(this.window, 'move', this.handleTopMoveCapture, true);\n        this.removeEventListener(this.window, 'move', this.handleTopMove);\n        this.removeEventListener(this.window, 'end', this.handleTopMoveEndCapture, true);\n        if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n            this.removeEventListener(this.window, 'contextmenu', this.handleTopMoveEndCapture);\n        }\n        if (this.options.enableKeyboardEvents) {\n            this.removeEventListener(this.window, 'keydown', this.handleCancelOnEscape, true);\n        }\n        this.uninstallSourceNodeRemovalObserver();\n    };\n    TouchBackend.prototype.addEventListener = function (subject, event, handler, capture) {\n        var options = supportsPassive_1.default ? { capture: capture, passive: false } : capture;\n        this.listenerTypes.forEach(function (listenerType) {\n            var evt = eventNames[listenerType][event];\n            if (evt) {\n                subject.addEventListener(evt, handler, options);\n            }\n        });\n    };\n    TouchBackend.prototype.removeEventListener = function (subject, event, handler, capture) {\n        var options = supportsPassive_1.default ? { capture: capture, passive: false } : capture;\n        this.listenerTypes.forEach(function (listenerType) {\n            var evt = eventNames[listenerType][event];\n            if (evt) {\n                subject.removeEventListener(evt, handler, options);\n            }\n        });\n    };\n    TouchBackend.prototype.connectDragSource = function (sourceId, node) {\n        var _this = this;\n        var handleMoveStart = this.handleMoveStart.bind(this, sourceId);\n        this.sourceNodes[sourceId] = node;\n        this.addEventListener(node, 'start', handleMoveStart);\n        return function () {\n            delete _this.sourceNodes[sourceId];\n            _this.removeEventListener(node, 'start', handleMoveStart);\n        };\n    };\n    TouchBackend.prototype.connectDragPreview = function (sourceId, node, options) {\n        var _this = this;\n        this.sourcePreviewNodeOptions[sourceId] = options;\n        this.sourcePreviewNodes[sourceId] = node;\n        return function () {\n            delete _this.sourcePreviewNodes[sourceId];\n            delete _this.sourcePreviewNodeOptions[sourceId];\n        };\n    };\n    TouchBackend.prototype.connectDropTarget = function (targetId, node) {\n        var _this = this;\n        if (!this.document) {\n            return function () { return null; };\n        }\n        var handleMove = function (e) {\n            if (!_this.document || !_this.monitor.isDragging()) {\n                return;\n            }\n            var coords;\n            /**\n             * Grab the coordinates for the current mouse/touch position\n             */\n            switch (e.type) {\n                case eventNames.mouse.move:\n                    coords = {\n                        x: e.clientX,\n                        y: e.clientY,\n                    };\n                    break;\n                case eventNames.touch.move:\n                    coords = {\n                        x: e.touches[0].clientX,\n                        y: e.touches[0].clientY,\n                    };\n                    break;\n            }\n            /**\n             * Use the coordinates to grab the element the drag ended on.\n             * If the element is the same as the target node (or any of it's children) then we have hit a drop target and can handle the move.\n             */\n            var droppedOn = coords != null\n                ? _this.document.elementFromPoint(coords.x, coords.y)\n                : undefined;\n            var childMatch = droppedOn && node.contains(droppedOn);\n            if (droppedOn === node || childMatch) {\n                return _this.handleMove(e, targetId);\n            }\n        };\n        /**\n         * Attaching the event listener to the body so that touchmove will work while dragging over multiple target elements.\n         */\n        this.addEventListener(this.document.body, 'move', handleMove);\n        this.targetNodes[targetId] = node;\n        return function () {\n            if (_this.document) {\n                delete _this.targetNodes[targetId];\n                _this.removeEventListener(_this.document.body, 'move', handleMove);\n            }\n        };\n    };\n    TouchBackend.prototype.getTopMoveStartHandler = function () {\n        if (!this.options.delayTouchStart && !this.options.delayMouseStart) {\n            return this.handleTopMoveStart;\n        }\n        return this.handleTopMoveStartDelay;\n    };\n    TouchBackend.prototype.installSourceNodeRemovalObserver = function (node) {\n        var _this = this;\n        this.uninstallSourceNodeRemovalObserver();\n        this.draggedSourceNode = node;\n        this.draggedSourceNodeRemovalObserver = new MutationObserver(function () {\n            if (node && !node.parentElement) {\n                _this.resurrectSourceNode();\n                _this.uninstallSourceNodeRemovalObserver();\n            }\n        });\n        if (!node || !node.parentElement) {\n            return;\n        }\n        this.draggedSourceNodeRemovalObserver.observe(node.parentElement, {\n            childList: true,\n        });\n    };\n    TouchBackend.prototype.resurrectSourceNode = function () {\n        if (this.document && this.draggedSourceNode) {\n            this.draggedSourceNode.style.display = 'none';\n            this.draggedSourceNode.removeAttribute('data-reactid');\n            this.document.body.appendChild(this.draggedSourceNode);\n        }\n    };\n    TouchBackend.prototype.uninstallSourceNodeRemovalObserver = function () {\n        if (this.draggedSourceNodeRemovalObserver) {\n            this.draggedSourceNodeRemovalObserver.disconnect();\n        }\n        this.draggedSourceNodeRemovalObserver = undefined;\n        this.draggedSourceNode = undefined;\n    };\n    return TouchBackend;\n}());\nexports.default = TouchBackend;\n"]},"metadata":{},"sourceType":"script"}