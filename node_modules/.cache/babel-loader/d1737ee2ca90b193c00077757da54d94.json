{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar invariant_1 = __importDefault(require(\"invariant\"));\n\nvar matchesType_1 = __importDefault(require(\"../../utils/matchesType\"));\n\nvar types_1 = require(\"./types\");\n\nfunction createHover(manager) {\n  return function hover(targetIdsArg, _a) {\n    var clientOffset = (_a === void 0 ? {} : _a).clientOffset;\n    verifyTargetIdsIsArray(targetIdsArg);\n    var targetIds = targetIdsArg.slice(0);\n    var monitor = manager.getMonitor();\n    var registry = manager.getRegistry();\n    checkInvariants(targetIds, monitor, registry);\n    var draggedItemType = monitor.getItemType();\n    removeNonMatchingTargetIds(targetIds, registry, draggedItemType);\n    hoverAllTargets(targetIds, monitor, registry);\n    return {\n      type: types_1.HOVER,\n      payload: {\n        targetIds: targetIds,\n        clientOffset: clientOffset || null\n      }\n    };\n  };\n}\n\nexports.default = createHover;\n\nfunction verifyTargetIdsIsArray(targetIdsArg) {\n  invariant_1.default(Array.isArray(targetIdsArg), 'Expected targetIds to be an array.');\n}\n\nfunction checkInvariants(targetIds, monitor, registry) {\n  invariant_1.default(monitor.isDragging(), 'Cannot call hover while not dragging.');\n  invariant_1.default(!monitor.didDrop(), 'Cannot call hover after drop.');\n\n  for (var i = 0; i < targetIds.length; i++) {\n    var targetId = targetIds[i];\n    invariant_1.default(targetIds.lastIndexOf(targetId) === i, 'Expected targetIds to be unique in the passed array.');\n    var target = registry.getTarget(targetId);\n    invariant_1.default(target, 'Expected targetIds to be registered.');\n  }\n}\n\nfunction removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {\n  // Remove those targetIds that don't match the targetType.  This\n  // fixes shallow isOver which would only be non-shallow because of\n  // non-matching targets.\n  for (var i = targetIds.length - 1; i >= 0; i--) {\n    var targetId = targetIds[i];\n    var targetType = registry.getTargetType(targetId);\n\n    if (!matchesType_1.default(targetType, draggedItemType)) {\n      targetIds.splice(i, 1);\n    }\n  }\n}\n\nfunction hoverAllTargets(targetIds, monitor, registry) {\n  // Finally call hover on all matching targets.\n  targetIds.forEach(function (targetId) {\n    var target = registry.getTarget(targetId);\n    target.hover(monitor, targetId);\n  });\n}","map":{"version":3,"sources":["/home/janne/repot/OperaatioJyrki/node_modules/dnd-core-cjs/lib/actions/dragDrop/hover.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","invariant_1","require","matchesType_1","types_1","createHover","manager","hover","targetIdsArg","_a","clientOffset","verifyTargetIdsIsArray","targetIds","slice","monitor","getMonitor","registry","getRegistry","checkInvariants","draggedItemType","getItemType","removeNonMatchingTargetIds","hoverAllTargets","type","HOVER","payload","default","Array","isArray","isDragging","didDrop","i","length","targetId","lastIndexOf","target","getTarget","targetType","getTargetType","splice","forEach"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = __importDefault(require(\"invariant\"));\nvar matchesType_1 = __importDefault(require(\"../../utils/matchesType\"));\nvar types_1 = require(\"./types\");\nfunction createHover(manager) {\n    return function hover(targetIdsArg, _a) {\n        var clientOffset = (_a === void 0 ? {} : _a).clientOffset;\n        verifyTargetIdsIsArray(targetIdsArg);\n        var targetIds = targetIdsArg.slice(0);\n        var monitor = manager.getMonitor();\n        var registry = manager.getRegistry();\n        checkInvariants(targetIds, monitor, registry);\n        var draggedItemType = monitor.getItemType();\n        removeNonMatchingTargetIds(targetIds, registry, draggedItemType);\n        hoverAllTargets(targetIds, monitor, registry);\n        return {\n            type: types_1.HOVER,\n            payload: {\n                targetIds: targetIds,\n                clientOffset: clientOffset || null,\n            },\n        };\n    };\n}\nexports.default = createHover;\nfunction verifyTargetIdsIsArray(targetIdsArg) {\n    invariant_1.default(Array.isArray(targetIdsArg), 'Expected targetIds to be an array.');\n}\nfunction checkInvariants(targetIds, monitor, registry) {\n    invariant_1.default(monitor.isDragging(), 'Cannot call hover while not dragging.');\n    invariant_1.default(!monitor.didDrop(), 'Cannot call hover after drop.');\n    for (var i = 0; i < targetIds.length; i++) {\n        var targetId = targetIds[i];\n        invariant_1.default(targetIds.lastIndexOf(targetId) === i, 'Expected targetIds to be unique in the passed array.');\n        var target = registry.getTarget(targetId);\n        invariant_1.default(target, 'Expected targetIds to be registered.');\n    }\n}\nfunction removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {\n    // Remove those targetIds that don't match the targetType.  This\n    // fixes shallow isOver which would only be non-shallow because of\n    // non-matching targets.\n    for (var i = targetIds.length - 1; i >= 0; i--) {\n        var targetId = targetIds[i];\n        var targetType = registry.getTargetType(targetId);\n        if (!matchesType_1.default(targetType, draggedItemType)) {\n            targetIds.splice(i, 1);\n        }\n    }\n}\nfunction hoverAllTargets(targetIds, monitor, registry) {\n    // Finally call hover on all matching targets.\n    targetIds.forEach(function (targetId) {\n        var target = registry.getTarget(targetId);\n        target.hover(monitor, targetId);\n    });\n}\n"]},"metadata":{},"sourceType":"script"}